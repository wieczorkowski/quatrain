import { 
    HorizontalLineAnnotation, 
    BoxAnnotation,
    LineAnnotation,
    CustomAnnotation,
    NativeTextAnnotation
// } from 'scichart/Charting/Visuals/Annotations';
} from 'scichart';
import { getReadableTextColor, getArrowAnchorPoints } from './chartUtils';

/**
 * Determines if an annotation is a strategy annotation
 * @param {Object} annotation - The annotation object
 * @returns {boolean} - True if this is a strategy annotation
 */
const isStrategyAnnotation = (annotation) => {
    // Check if clientid starts with "strategy"
    if (annotation.clientid && annotation.clientid.startsWith('strategy')) {
        return true;
    }
    
    // Check if id starts with "strategy"
    if (annotation.id && annotation.id.startsWith('strategy')) {
        return true;
    }
    
    // Check if annotation has an isStrategyAnnotation flag
    if (annotation.isStrategyAnnotation) {
        return true;
    }
    
    return false;
};

/**
 * Rebuilds saved annotations on the specified charts
 * @param {Array} annotations - Array of annotation objects to rebuild
 * @param {Array} timeframes - Array of timeframes to apply annotations to
 * @param {object} sciChartSurfaceRefs - References to SciChart surfaces
 * @param {Function|null} handleAnnotationUpdated - Function to handle annotation updates
 * @param {boolean} isDrawingLockMode - Whether drawing lock mode is active
 */
export function rebuildSavedAnnotations(annotations, timeframes, sciChartSurfaceRefs, handleAnnotationUpdated, isDrawingLockMode = false) {
    if (!annotations || !timeframes || !sciChartSurfaceRefs || !sciChartSurfaceRefs.current) {
        console.warn('Cannot rebuild annotations: missing required parameters');
        return;
    }
    
    annotations.forEach(anno => {
        // Determine which charts to apply this annotation to
        const targetTimeframes = anno.timeframe === 'all' 
            ? timeframes  // Apply to all charts
            : [anno.timeframe]; // Apply to specific chart
        
        targetTimeframes.forEach(timeframe => {
            // Get the chart surface for this timeframe
            const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
            if (!sciChartSurface) {
                console.warn(`Cannot add annotation to ${timeframe} - chart not initialized`);
                return;
            }
            
            // Reconstruct the full ID that would have been generated by generateAnnotationId
            const expectedId = `${anno.clientid}/${anno.instrument}/${anno.timeframe}/${anno.annotype}/${anno.unique}`;
            
            // Check if annotation with this ID already exists on the chart
            const existingAnnotations = sciChartSurface.annotations.asArray();
            const existingAnnotation = existingAnnotations.find(a => a.id === expectedId);
            
            if (existingAnnotation) {
                // If annotation already exists, just update its isEditable property based on drawing lock mode
                const isStrategy = isStrategyAnnotation(anno);
                existingAnnotation.isEditable = shouldAnnotationBeEditable(isDrawingLockMode, isStrategy);
                
                // When in drawing lock mode, always deselect the annotation
                if (isDrawingLockMode) {
                    existingAnnotation.isSelected = false;
                }
                
                // console.log(`Updated existing ${anno.annotype} annotation with ID ${anno.unique} on ${timeframe} chart`);
            } else {
                // Create the annotation based on type
                const annotation = createAnnotationFromSaved(anno, sciChartSurface, timeframe, handleAnnotationUpdated, isDrawingLockMode);
                
                if (annotation) {
                    // Add the annotation to the chart
                    sciChartSurface.annotations.add(annotation);
                    // console.log(`Rebuilt ${anno.annotype} annotation with ID ${anno.unique} on ${timeframe} chart`);
                }
            }
            
            // Refresh the chart to apply changes
            sciChartSurface.invalidateElement();
        });
    });
}

/**
 * Determines if an annotation should be editable based on drawing lock mode and whether it's a strategy annotation
 * @param {boolean} isDrawingLockMode - Whether drawing lock mode is active
 * @param {boolean} isStrategy - Whether the annotation is a strategy annotation
 * @returns {boolean} - Whether the annotation should be editable
 */
export function shouldAnnotationBeEditable(isDrawingLockMode, isStrategy) {
    // Strategy annotations are never editable
    if (isStrategy) {
        return false;
    }
    
    // User annotations are editable only when drawing lock mode is off
    return !isDrawingLockMode;
}

/**
 * Creates a SciChart annotation from saved annotation data
 * @param {Object} savedAnnotation - The saved annotation data from the server
 * @param {SciChartSurface} sciChartSurface - The chart surface to add the annotation to
 * @param {string} timeframe - The current timeframe
 * @param {Function|null} handleAnnotationUpdated - Handler for annotation updates, null for strategy annotations
 * @param {boolean} isDrawingLockMode - Whether drawing lock mode is active
 * @returns {Annotation|null} - The created annotation or null if creation failed
 */
export function createAnnotationFromSaved(savedAnnotation, sciChartSurface, timeframe, handleAnnotationUpdated, isDrawingLockMode = false) {
    const { annotype, unique, object, clientid, instrument } = savedAnnotation;
    if (!object) {
        console.error('Annotation object is missing required properties');
        return null;
    }
    
    // Determine if this is a strategy annotation
    const isStrategy = isStrategyAnnotation(savedAnnotation);
    
    // Set isEditable based on drawing lock mode and annotation type
    const isEditable = shouldAnnotationBeEditable(isDrawingLockMode, isStrategy);
    
    // Always set isSelected to false when in drawing lock mode
    const isSelected = isDrawingLockMode ? false : false; // Default to false in all cases for now
    
    // Reconstruct the full ID that would have been generated by generateAnnotationId
    const id = `${clientid}/${instrument}/${savedAnnotation.timeframe}/${annotype}/${unique}`;
    
    // Base properties common to all annotation types
    const { 
        stroke, 
        strokeThickness, 
        x1, 
        y1
    } = object;
    
    let annotation = null;
    
    // Create the annotation based on its type
    if (annotype === 'hline') {
        annotation = new HorizontalLineAnnotation({
            id,
            stroke,
            strokeThickness,
            strokeDashArray: object.strokeDashArray || [],
            y1,
            x1: object.x1, // For Right orientation if specified
            isEditable,
            isSelected,
            showLabel: object.showLabel || false,
            labelPlacement: object.labelPlacement || "Axis",
            labelValue: object.labelValue || y1.toFixed(2),
            axisLabelFill: object.axisLabelFill || stroke,
            axisLabelStroke: object.axisLabelStroke || getReadableTextColor(stroke),
            fontSize: object.fontSize || 12,
            yAxisId: 'yAxis',
            ...(isStrategy ? {} : {
                // Only add these handlers for non-strategy annotations
                onDrag: () => {
                    // Update label value during drag to match current y1 value
                    annotation.labelValue = annotation.y1.toFixed(2);
                    sciChartSurface.invalidateElement();
                },
                onDragEnded: () => {
                    // Call the update handler when dragging is complete
                    // console.log(`Handler: Line drag ended on ${timeframe} chart for rebuilt annotation`);
                    handleAnnotationUpdated(annotation, timeframe);
                }
            })
        });
    } else if (annotype === 'box') {
        annotation = new BoxAnnotation({
            id,
            stroke,
            strokeThickness,
            fill: object.fill || 'rgba(255,0,0,0.2)',
            x1,
            y1,
            x2: object.x2,
            y2: object.y2,
            isEditable,
            isSelected,
            annotationLayer: object.annotationLayer || "Background",
            ...(isStrategy ? {} : {
                // Only add these handlers for non-strategy annotations
                onDrag: () => {
                    // Just invalidate the element during drag
                    sciChartSurface.invalidateElement();
                },
                onDragEnded: () => {
                    // Call the update handler when box drag is finished
                    // console.log(`Handler: Box drag ended on ${timeframe} chart for rebuilt annotation`);
                    handleAnnotationUpdated(annotation, timeframe);
                }
            })
        });
    } else if (annotype === 'tline') {
        annotation = new LineAnnotation({
            id,
            stroke,
            strokeThickness,
            strokeDashArray: object.strokeDashArray || [],
            x1,
            y1,
            x2: object.x2,
            y2: object.y2,
            isEditable,
            isSelected,
            xAxisId: 'xAxis',
            yAxisId: 'yAxis',
            ...(isStrategy ? {} : {
                // Only add these handlers for non-strategy annotations
                onDrag: () => {
                    // Just invalidate the element during drag
                    sciChartSurface.invalidateElement();
                },
                onDragEnded: () => {
                    // Call the update handler when trendline drag is finished
                    // console.log(`Handler: Trendline drag ended on ${timeframe} chart for rebuilt annotation`);
                    handleAnnotationUpdated(annotation, timeframe);
                }
            })
        });
    } else if (annotype === 'arrow') {
        // For arrow annotations, get the "default"anchor points
        
        // console.log(`[DEBUG] - Arrow object = ${JSON.stringify(object)}`);
        const anchorPoints = getArrowAnchorPoints(object.arrowDirection || 'up');
        
        
        annotation = new CustomAnnotation({
            id,
            x1,
            y1,
            svgString: object.svgString,
            
            // horizontalAnchorPoint: anchorPoints.horizontalAnchorPoint,
            // verticalAnchorPoint: anchorPoints.verticalAnchorPoint,
            // Use the saved anchor points if they exist, otherwise use the default anchor points
            horizontalAnchorPoint: (object.horizontalAnchorPoint || anchorPoints.horizontalAnchorPoint),
            verticalAnchorPoint: (object.verticalAnchorPoint || anchorPoints.verticalAnchorPoint),
            xAxisId: 'xAxis',
            yAxisId: 'yAxis',
            isEditable,
            isSelected,
            ...(isStrategy ? {} : {
                // Only add these handlers for non-strategy annotations
                onDrag: () => {
                    // Just invalidate the element during drag
                    sciChartSurface.invalidateElement();
                },
                onDragEnded: () => {
                    // Call the update handler when arrow drag is finished
                    // console.log(`Handler: Arrow drag ended on ${timeframe} chart for rebuilt annotation`);
                    handleAnnotationUpdated(annotation, timeframe);
                }
            })
        });
        
        // Store arrow specific properties for later use
        if (object.arrowDirection) annotation.arrowDirection = object.arrowDirection;
        if (object.arrowSize) annotation.arrowSize = object.arrowSize;
        if (object.arrowStyle) annotation.arrowStyle = object.arrowStyle;

        // console.log(`[DEBUG] - Arrow x1 = ${annotation.x1}, y1 = ${annotation.y1}`);
        // console.log(`[DEBUG] - Arrow HAP = ${annotation.horizontalAnchorPoint}, VAP = ${annotation.verticalAnchorPoint}`);   
    } else if (annotype === 'text') {
        annotation = new NativeTextAnnotation({
            id,
            x1,
            y1,
            text: object.text || '',
            textColor: object.textColor || stroke,
            backgroundColor: 'transparent',
            fontSize: object.fontSize || 14,
            fontWeight: 'bold', 
            horizontalAnchorPoint: object.horizontalAnchorPoint || HorizontalAnchorPoint.Center,
            verticalAnchorPoint: object.verticalAnchorPoint || VerticalAnchorPoint.Center,
            xAxisId: 'xAxis',
            yAxisId: 'yAxis',
            isEditable,
            isSelected,
            ...(isStrategy ? {} : {
                // Only add these handlers for non-strategy annotations
                onDrag: () => {
                    // Just invalidate the element during drag
                    sciChartSurface.invalidateElement();
                },
                onDragEnded: () => {
                    // Call the update handler when text annotation drag is finished
                    // console.log(`Handler: Text annotation drag ended on ${timeframe} chart for rebuilt annotation`);
                    handleAnnotationUpdated(annotation, timeframe);
                }
            })
        });
    } else {
        console.warn(`Unknown annotation type: ${annotype}`);
        return null;
    }
    
    return annotation;
}

/**
 * Deletes a specific annotation from all chart surfaces based on the strategy clientId and uniqueId
 * @param {string} strategyClientId - The client ID of the strategy (first part of the annotation ID)
 * @param {string} uniqueId - The unique ID of the annotation (fifth part of the annotation ID)
 * @param {Object} sciChartSurfaceRefs - References to chart surfaces
 * @param {Array} timeframes - Array of timeframes available in the app
 * @returns {boolean} - True if at least one annotation was found and deleted
 */
export function deleteAnnotationByIds(strategyClientId, uniqueId, sciChartSurfaceRefs, timeframes) {
    // console.log(`[MEMORY DEBUG] Attempting to delete annotation with strategyClientId: ${strategyClientId}, uniqueId: ${uniqueId}`);
    
    let annotationFound = false;
    let totalAnnotationsBeforeDelete = 0;
    let totalAnnotationsAfterDelete = 0;
    
    // First, count total annotations before deletion
    timeframes.forEach(timeframe => {
        const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
        if (sciChartSurface) {
            totalAnnotationsBeforeDelete += sciChartSurface.annotations.size();
        }
    });
    
    // Check all timeframes
    timeframes.forEach(timeframe => {
        const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
        if (!sciChartSurface) {
            console.warn(`Cannot check ${timeframe} chart - not initialized`);
            return;
        }
        
        // Get all annotations on this chart
        const annotations = sciChartSurface.annotations;
        const toRemove = [];
        
        // console.log(`[MEMORY DEBUG] Checking ${annotations.size()} annotations on ${timeframe} chart`);
        
        // Find annotations that match our criteria
        for (let i = 0; i < annotations.size(); i++) {
            const annotation = annotations.get(i);
            if (annotation.id) {
                // Parse the ID to extract components
                const idParts = annotation.id.split('/');
                
                // Check if this annotation matches our criteria:
                // - First part of ID matches strategyClientId
                // - Fifth part of ID matches uniqueId
                if (idParts.length >= 5 && 
                    idParts[0] === strategyClientId && 
                    idParts[4] === uniqueId) {
                    toRemove.push(annotation);
                    annotationFound = true;
                    // console.log(`[MEMORY DEBUG] Found matching annotation: ${annotation.id} on ${timeframe}`);
                }
            }
        }
        
        // Remove any matching annotations
        if (toRemove.length > 0) {
            // console.log(`[MEMORY DEBUG] Removing ${toRemove.length} matching annotations on ${timeframe} chart`);
            toRemove.forEach(anno => {
                annotations.remove(anno);
                // Call delete() method on annotation if it exists to free WebGL resources
                if (typeof anno.delete === 'function') {
                    try {
                        anno.delete();
                        // console.log(`[MEMORY DEBUG] Successfully called delete() on annotation ${anno.id}`);
                    } catch (error) {
                        console.warn(`[MEMORY DEBUG] Error calling delete() on annotation: ${error.message}`);
                    }
                } else {
                    console.warn(`[MEMORY DEBUG] Annotation ${anno.id} does not have delete() method`);
                }
            });
            
            // Redraw the chart
            sciChartSurface.invalidateElement();
        }
    });
    
    // Count total annotations after deletion
    timeframes.forEach(timeframe => {
        const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
        if (sciChartSurface) {
            totalAnnotationsAfterDelete += sciChartSurface.annotations.size();
        }
    });
    
    // console.log(`[MEMORY DEBUG] Deletion complete. Annotations before: ${totalAnnotationsBeforeDelete}, after: ${totalAnnotationsAfterDelete}, removed: ${totalAnnotationsBeforeDelete - totalAnnotationsAfterDelete}`);
    
    return annotationFound;
}

/**
 * Utility function to audit annotations and check for potential memory issues
 * @param {Object} sciChartSurfaceRefs - References to chart surfaces
 * @param {Array} timeframes - Array of timeframes
 * @returns {Object} - Audit report with annotation counts and potential issues
 */
export function auditAnnotations(sciChartSurfaceRefs, timeframes) {
    const audit = {
        totalAnnotations: 0,
        annotationsByTimeframe: {},
        annotationsByStrategy: {},
        duplicateIds: [],
        orphanedAnnotations: [],
        memoryUsageEstimate: 0
    };
    
    const seenIds = new Set();
    const duplicateTracker = new Map();
    
    timeframes.forEach(timeframe => {
        const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
        if (!sciChartSurface) {
            audit.annotationsByTimeframe[timeframe] = 0;
            return;
        }
        
        const annotations = sciChartSurface.annotations;
        const count = annotations.size();
        audit.annotationsByTimeframe[timeframe] = count;
        audit.totalAnnotations += count;
        
        // Estimate memory usage (rough calculation)
        audit.memoryUsageEstimate += count * 1024; // Estimate 1KB per annotation
        
        // Check each annotation
        for (let i = 0; i < count; i++) {
            const annotation = annotations.get(i);
            
            if (annotation.id) {
                // Track duplicate IDs across timeframes
                if (seenIds.has(annotation.id)) {
                    if (!duplicateTracker.has(annotation.id)) {
                        duplicateTracker.set(annotation.id, []);
                    }
                    duplicateTracker.get(annotation.id).push(timeframe);
                } else {
                    seenIds.add(annotation.id);
                }
                
                // Parse ID to get strategy info
                const idParts = annotation.id.split('/');
                if (idParts.length >= 5) {
                    const strategyClientId = idParts[0];
                    if (!audit.annotationsByStrategy[strategyClientId]) {
                        audit.annotationsByStrategy[strategyClientId] = 0;
                    }
                    audit.annotationsByStrategy[strategyClientId]++;
                } else {
                    // Invalid ID format - potential orphan
                    audit.orphanedAnnotations.push({
                        timeframe,
                        id: annotation.id,
                        type: annotation.type || 'unknown'
                    });
                }
            } else {
                // No ID - potential orphan
                audit.orphanedAnnotations.push({
                    timeframe,
                    id: 'NO_ID',
                    type: annotation.type || 'unknown'
                });
            }
        }
    });
    
    // Convert duplicate tracker to array format
    duplicateTracker.forEach((timeframes, id) => {
        audit.duplicateIds.push({
            id,
            timeframes: timeframes,
            count: timeframes.length + 1 // +1 for the original
        });
    });
    
    return audit;
}

/**
 * Utility function to clean up orphaned or duplicate annotations
 * @param {Object} sciChartSurfaceRefs - References to chart surfaces
 * @param {Array} timeframes - Array of timeframes
 * @returns {Object} - Cleanup report
 */
export function cleanupAnnotations(sciChartSurfaceRefs, timeframes) {
    const cleanupReport = {
        orphanedRemoved: 0,
        duplicatesRemoved: 0,
        totalRemoved: 0
    };
    
    const seenIds = new Map(); // Map of ID to timeframe where it was first seen
    
    timeframes.forEach(timeframe => {
        const sciChartSurface = sciChartSurfaceRefs.current[timeframe];
        if (!sciChartSurface) return;
        
        const annotations = sciChartSurface.annotations;
        const toRemove = [];
        
        for (let i = 0; i < annotations.size(); i++) {
            const annotation = annotations.get(i);
            let shouldRemove = false;
            
            if (!annotation.id) {
                // No ID - remove as orphaned
                shouldRemove = true;
                cleanupReport.orphanedRemoved++;
            } else {
                const idParts = annotation.id.split('/');
                if (idParts.length < 5) {
                    // Invalid ID format - remove as orphaned
                    shouldRemove = true;
                    cleanupReport.orphanedRemoved++;
                } else if (seenIds.has(annotation.id)) {
                    // Duplicate ID - remove this instance
                    shouldRemove = true;
                    cleanupReport.duplicatesRemoved++;
                    // console.log(`Removing duplicate annotation ${annotation.id} from ${timeframe} (original in ${seenIds.get(annotation.id)})`);
                } else {
                    // Valid and unique - track it
                    seenIds.set(annotation.id, timeframe);
                }
            }
            
            if (shouldRemove) {
                toRemove.push(annotation);
                cleanupReport.totalRemoved++;
            }
        }
        
        // Remove the collected annotations
        toRemove.forEach(anno => {
            annotations.remove(anno);
            // Call delete() method on annotation if it exists to free WebGL resources
            if (typeof anno.delete === 'function') {
                try {
                    anno.delete();
                } catch (error) {
                    console.warn(`Error calling delete() on annotation: ${error.message}`);
                }
            }
        });
        
        if (toRemove.length > 0) {
            sciChartSurface.invalidateElement();
        }
    });
    
    return cleanupReport;
} 