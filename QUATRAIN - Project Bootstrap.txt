DESCRIPTION - QUATRAIN

"Quatrain" is an app for charting, analyzing, and trading financial instruments. 

It requests data from a back-end server (Chronicle) and receives that data as OHLCV "candle" data, in multiple different timeframe aggregations. It then uses the SciChart API to render this data as "candlestick" graphs across either four panes or six. Each chart shows candles aggregated by a specific timeframe. (in 4-way mode, 1h, 15m, 5m, and 1m -- in 6-way mode, 1h, 30m, 15m, 10m, 5m, and 1m)


TECHNOLOGIES:

Quatrain is primarily written in JavaScript and runs in the NPM environment. The user interface uses React to render the various screens for the user. 

Communication with the back-end is over WebSocket, using structured JSON messages. Quatrain sends request messages to the Chronicle server, and Chronicle sends back messages of various types (mtyp) to Quatrain. Actual financial instrument data is sent using "mtyp":"data" in OHLCV format for each requested aggregation and is routed to the appropriate chart and data series by Quatrain.

The charts themselves, chart details, studies, and annotations are displayed using the SciChart JS API. The data itself is rendered as SciChart "candlestick" data. 

Quatrain is capable of opening multiple windows, and uses Electron to present these windows similar to those of a desktop app. 

While IPC is used for simple communications between Electron windows, Quatrain implements a custom "Shared Data Service" for sharing data between windows. This is the preferred method for communication between component windows, such as between the main charting window and the windows involved in Trade Manager. "Redux" was used at one time, but its use has been deprecated in favor of the Shared Data Client structure.

Version Management is currently done manually by the development team. The project does not currently use Git or any other external software management.

Code is almost entirely written by A.I. in the "Cursor" IDE.


QUATRAIN FUNCTIONS:

* ANNOTATIONS - Quatrain allows users to draw annotations on charts. User annotations are managed via a defined system of identification and configuration, and user-drawn annotations are saved to the back-end database and recalled when Quatrain is restarted.

* USER SETTINGS - Quatrain allows users to configure their charting environment. Information on settings is stored in the back-end's database and recalled when a user re-connects.


QUATRAIN STRATEGIES:

* Quatrain has the capacity to run "strategy" code to analyze chart data and annotate charts to indicate items of interest for active traders. Currently Quatrain supports three mechanisms for this:

1) EXTERNAL STRATEGIES - Quatrain can forward data to an external "strategy" client, which can conduct analysis on that data independently and send "strategy annotation" messages to the Chronicle back-end, which will be forwarded to Quatrain clients who subscribe to them as mtyp:strategy messages. Quatrain can then render those messages on its charts. The configuration is complicated and the context is limited, so external strategy, while still supported, is not preferred.

2) INTERNAL STRATEGIES - Several studies have been coded directly into Quatrain as "Internal Strategies". They run under the Quatrain main window and have direct access to both the candle data (via a UseEffect) and the SciChart annotation API, and can perform calculations and place annotations directly on the appropriate charts. While this approach is much more real-time and integrated than external strategies, the overhead of multiple hooks and the static inclusion in the code presents some challenges.

3) USER STUDIES (preferred) - Studies can be built in their own self-contained script files and loaded dynamically into Quatrain. This functions similar to Internal Strategies, but the dynamic discovery and single data-stream provides some performance benefits. We are working to improve this mechanism for both better performance and more dynamic integration, as opposed to build-time integration.


QUATRAIN TRADING:

Quatrain offers users the ability to trade intelligently, utilizing the Quatrain chart data in combination with an external broker account. Currently Quatrain only supports connectivity to the NinjaTrader desktop app via a custom "NinjaScript" C# bridge add-on, which allows Quatrain users to place and manage trades and get information on positions and active orders. At some future time we will evaluate connectivity to other trading platforms.

In addition to standard market/limit/stop orders, Quatrain also has some interesting features intended to facilitate easy trading based on current data:

* CHART TRADER - Allows users to place orders simply by clicking on one of the candle charts. This allows precise placement of orders based on graphical analysis, rather than relying on manually inputting a price or using a "ladder/DOM" element. Future enhancements will include the ability to modify orders on the chart by dragging order annotations.

* SMART STOP - Modifies user stop-loss orders based on position quantity and/or price in relation to current data. This allows for intelligent management and reduction of risk based on trade status and market conditions.


QUATRAIN MODES

Quatrain has several modes of operation, which can be selected on initial connection:

* LIVE - Quatrain requests live data from the Chronicle server. Historical OHLCV candles are loaded for a certain prior interval, and then "live" data is presented every "tick" in OHLCV format, for each aggregation. The "Live" candle is updated on an "add or replace" logic - each update is the full OHLCV data for that candle for that interval. If the start timestamp matches, the "live" candle is replaced on the charts. If it does not (if it's the next candle), it is added to the data series.

* HISTORY ONLY - Like LIVE, but only loads historical data - does not feed live candle updates. Used for functional and graphical testing, primarily.

* REPLAY - Requests historical data from the server, but data is sent as a candle-stream, similar to how live data would be sent. Since data is reconstructed from 1m OHLCV data, a new minute is pushed with each update, which is controlled by a user-specified update interval.



