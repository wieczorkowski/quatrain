DESCRIPTION - QUATRAIN

"Quatrain" is an app for charting, analyzing, and trading financial instruments. 

It requests data from a back-end server (Chronicle) and receives that data as OHLCV "candle" data, in multiple different timeframe aggregations. It then uses the SciChart API to render this data as "candlestick" graphs across either four panes or six. Each chart shows candles aggregated by a specific timeframe. (in 4-way mode, 1h, 15m, 5m, and 1m -- in 6-way mode, 1h, 30m, 15m, 10m, 5m, and 1m)


TECHNOLOGIES:

Quatrain is primarily written in JavaScript and runs in the NPM environment. The user interface uses React to render the various screens for the user. 

Communication with the back-end is over WebSocket, using structured JSON messages. Quatrain sends request messages to the Chronicle server, and Chronicle sends back messages of various types (mtyp) to Quatrain. Actual financial instrument data is sent using "mtyp":"data" in OHLCV format for each requested aggregation and is routed to the appropriate chart and data series by Quatrain.

The charts themselves, chart details, studies, and annotations are displayed using the SciChart JS API. The data itself is rendered as SciChart "candlestick" data. 

Quatrain is capable of opening multiple windows, and uses Electron to present these windows similar to those of a desktop app. 

While IPC is used for simple communications between Electron windows, Quatrain implements a custom "Shared Data Service" for sharing data between windows. This is the preferred method for communication between component windows, such as between the main charting window and the windows involved in Trade Manager. "Redux" was used at one time, but its use has been deprecated in favor of the Shared Data Client structure.

Version Management is currently done manually by the development team. The project does not currently use Git or any other external software management.

Code is mostly written by A.I. in the "Cursor" IDE.


QUATRAIN FUNCTIONS:

* ANNOTATIONS - Quatrain allows users to draw annotations on charts. User annotations are managed via a defined system of identification and configuration, and user-drawn annotations are saved to the back-end database and recalled when Quatrain is restarted.

* USER SETTINGS - Quatrain allows users to configure their charting environment. Information on settings is stored in the back-end's database and recalled when a user re-connects.

* STRATEGIES - Quatrain is capable of subscribing to strategy annotations generated by an external "Strategy Manager" component, which normally communicates through the back-end database. We are also in the process of building indicators, studies, and strategy management integrated into Quatrain itself.


QUATRAIN TRADING:

Quatrain offers users the ability to trade intelligently, utilizing the Quatrain chart data in combination with an external broker account. Currently Quatrain only supports connectivity to the NinjaTrader desktop app via a custom "NinjaScript" C# bridge add-on, which allows Quatrain users to place and manage trades and get information on positions and active orders. At some future time we will evaluate connectivity to other trading platforms.

In addition to standard market/limit/stop orders, Quatrain also has some interesting features intended to facilitate easy trading based on current data:

* CHART TRADER - Allows users to place orders simply by clicking on one of the candle charts. This allows precise placement of orders based on graphical analysis, rather than relying on manually inputting a price or using a "ladder/DOM" element. Future enhancements will include the ability to modify orders on the chart by dragging order annotations.

* SMART STOP - Modifies user stop-loss orders based on position quantity and/or price in relation to current data. This allows for intelligent management and reduction of risk based on trade status and market conditions.


QUATRAIN MODES

Quatrain has several modes of operation, which can be selected on initial connection:

* LIVE - Quatrain requests live data from the Chronicle server. Historical OHLCV candles are loaded for a certain prior interval, and then "live" data is presented every "tick" in OHLCV format, for each aggregation. The "Live" candle is updated on an "add or replace" logic - each update is the full OHLCV data for that candle for that interval. If the start timestamp matches, the "live" candle is replaced on the charts. If it does not (if it's the next candle), it is added to the data series.

* HISTORY ONLY - Like LIVE, but only loads historical data - does not feed live candle updates. Used for functional and graphical testing, primarily.

* REPLAY - Requests historical data from the server, but data is sent as a candle-stream, similar to how live data would be sent. Since data is reconstructed from 1m OHLCV data, a new minute is pushed with each update, which is controlled by a user-specified update interval.



